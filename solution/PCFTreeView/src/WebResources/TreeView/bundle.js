/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var pcf_tools_652ac3f36e1e4bca82eb3c1dc44e6fad;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./TreeView/TreeViewControl.tsx":
/*!**************************************!*
  !*** ./TreeView/TreeViewControl.tsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function () {\n  var _ownKeys = function ownKeys(o) {\n    _ownKeys = Object.getOwnPropertyNames || function (o) {\n      var ar = [];\n      for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n      return ar;\n    };\n    return _ownKeys(o);\n  };\n  return function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k = _ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n    __setModuleDefault(result, mod);\n    return result;\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TreeViewControl = void 0;\nvar React = __importStar(__webpack_require__(\"react\"));\nvar react_components_1 = __webpack_require__(\"@fluentui/react-components\");\nvar useStyles = (0, react_components_1.makeStyles)({\n  innerWrapper: {\n    alignItems: \"start\",\n    columnGap: \"8px\",\n    display: \"flex\"\n  },\n  OuterWrapper: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    rowGap: \"15px\",\n    minWidth: \"min-content\"\n  },\n  childTree: {\n    marginLeft: \"0px\"\n  },\n  treeContainer: {\n    minWidth: \"100%\",\n    width: \"max-content\",\n    whiteSpace: \"nowrap\",\n    overflow: \"hidden\"\n  },\n  treeItemLayout: {\n    display: \"inline-flex\",\n    alignItems: \"center\",\n    whiteSpace: \"nowrap\",\n    width: \"100%\",\n    padding: \"0\",\n    justifyContent: \"flex-start\"\n  },\n  nodeText: {\n    display: \"inline-flex\",\n    alignItems: \"center\",\n    whiteSpace: \"nowrap\",\n    gap: \"8px\"\n  },\n  key: {\n    fontWeight: \"bold\"\n  },\n  separator: {\n    color: \"#666\"\n  },\n  radio: {\n    marginRight: \"8px\",\n    marginLeft: \"0\"\n  }\n});\nvar TreeViewControl = _ref => {\n  var {\n    data,\n    buttonSize,\n    treeSize,\n    fontSize,\n    onSelectionChange\n  } = _ref;\n  var styles = useStyles();\n  var [openItems, setOpenItems] = React.useState([]);\n  var [treeData, setTreeData] = React.useState(data);\n  React.useEffect(() => {\n    console.log(\"Input data:\", JSON.stringify(data, null, 2));\n    setTreeData(data);\n  }, [data]);\n  var getSelectedKeys = items => {\n    var selected = [];\n    var collectSelected = nodes => {\n      nodes.forEach(item => {\n        if (item.isSelected) {\n          selected.push(item.key);\n        }\n        if (item.children) {\n          collectSelected(item.children);\n        }\n      });\n    };\n    try {\n      collectSelected(items);\n      var result = selected.join(\",\");\n      console.log(\"Selected keys:\", result);\n      return result;\n    } catch (error) {\n      console.error(\"Error in getSelectedKeys:\", error);\n      return \"\";\n    }\n  };\n  // NOTE: selectedState output removed; keep internal state only and expose changedRows delta\n  var handleExpandAll = () => {\n    var collectKeys = (items, allKeysCollected) => {\n      items.forEach(item => {\n        if (!item.key) {\n          console.error(\"Missing key in item:\", item);\n          return;\n        }\n        allKeysCollected.push(item.key);\n        if (item.children && item.children.length > 0) {\n          collectKeys(item.children, allKeysCollected);\n        }\n      });\n    };\n    try {\n      var allKeys = [];\n      collectKeys(treeData, allKeys);\n      setOpenItems(allKeys);\n    } catch (error) {\n      console.error(\"Error in handleExpandAll:\", error);\n    }\n  };\n  var handleCollapseAll = () => {\n    setOpenItems([]);\n  };\n  var handleOpenChange = (event, eventData) => {\n    try {\n      setOpenItems(curr => eventData.open ? [...curr, eventData.value] : curr.filter(item => item !== eventData.value));\n    } catch (error) {\n      console.error(\"Error in handleOpenChange:\", error);\n    }\n  };\n  var updateSelection = key => {\n    // New behavior requested:\n    // 1) Toggle the clicked node's isSelected (flip current state)\n    // 2) Clear (set false) all downstream descendants of the clicked node\n    // 3) Toggle each upstream ancestor's isSelected (flip each parent in the path)\n    try {\n      var cloned = JSON.parse(JSON.stringify(treeData));\n      // find path from root to target; returns array of nodes (references into cloned)\n      var _findPath = function findPath(items, targetKey) {\n        var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        for (var i = 0; i < items.length; i++) {\n          var node = items[i];\n          if (!node.key) continue;\n          var newPath = [...path, node];\n          if (node.key === targetKey) {\n            return newPath;\n          }\n          if (node.children && node.children.length > 0) {\n            var res = _findPath(node.children, targetKey, newPath);\n            if (res) return res;\n          }\n        }\n        return null;\n      };\n      var path = _findPath(cloned, key);\n      if (!path || path.length === 0) {\n        console.warn(\"updateSelection: key not found\", key);\n        return cloned;\n      }\n      var target = path[path.length - 1];\n      var current = !!target.isSelected;\n      var newSelected = !current;\n      // set target to toggled value\n      target.isSelected = newSelected;\n      // clear all descendants of target\n      var clearDescendants = node => {\n        if (!node.children || node.children.length === 0) return;\n        node.children.forEach(c => {\n          c.isSelected = false;\n          clearDescendants(c);\n        });\n      };\n      clearDescendants(target);\n      // when selecting the target, ensure all ancestors are selected\n      // when deselecting the target, leave ancestors unchanged\n      if (newSelected) {\n        for (var a = 0; a < path.length - 1; a++) {\n          var ancestor = path[a];\n          ancestor.isSelected = true;\n        }\n      }\n      console.log(\"Updated treeData:\", JSON.stringify(cloned, null, 2));\n      return cloned;\n    } catch (error) {\n      console.error(\"Error in updateSelection:\", error);\n      return treeData;\n    }\n  };\n  var handleCheckboxChange = (key, _checked) => {\n    try {\n      var previous = treeData;\n      var updatedData = updateSelection(key);\n      setTreeData(updatedData);\n      if (onSelectionChange) {\n        var selectedKeys = getSelectedKeys(updatedData);\n        // compute changed rows: nodes where isSelected differs between previous and updated\n        var changed = [];\n        var collectChanged = (prevNodes, newNodes) => {\n          if (!newNodes) return;\n          newNodes.forEach(n => {\n            var _a, _b;\n            var prev = (prevNodes || []).find(p => p.key === n.key);\n            if (!prev) {\n              // treat as changed\n              changed.push(\"\".concat(n.key, \"|\").concat(n.isSelected ? 'true' : 'false'));\n            } else if (((_a = prev.isSelected) !== null && _a !== void 0 ? _a : false) !== ((_b = n.isSelected) !== null && _b !== void 0 ? _b : false)) {\n              changed.push(\"\".concat(n.key, \"|\").concat(n.isSelected ? 'true' : 'false'));\n            }\n            if (n.children && n.children.length > 0) {\n              var prevChildren = prev ? prev.children : undefined;\n              collectChanged(prevChildren, n.children);\n            }\n          });\n        };\n        collectChanged(previous, updatedData);\n        var changedRows = changed.join('\\n');\n        onSelectionChange(updatedData, selectedKeys, changedRows);\n      }\n    } catch (error) {\n      console.error(\"Error in handleCheckboxChange:\", error);\n    }\n  };\n  var _renderTreeItems = function renderTreeItems(items) {\n    var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return items.map((item, index) => {\n      var _a, _b;\n      if (!item.key || !item.label) {\n        console.error(\"Invalid item at index \".concat(index, \":\"), item);\n        return null;\n      }\n      // inline style for node content: shift the radio+text block by level*20px\n      var nodeContentStyle = {\n        marginLeft: \"\".concat(level * 20, \"px\"),\n        display: \"inline-flex\",\n        alignItems: \"center\"\n      };\n      return React.createElement(react_components_1.TreeItem, {\n        key: item.key,\n        value: item.key,\n        as: \"div\",\n        \"aria-label\": \"\".concat(item.key, \" - \`).slice(0,4000) + "..."}