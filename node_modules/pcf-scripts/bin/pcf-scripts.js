#!/usr/bin/env node
"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const taskRunner_1 = require("../taskRunner");
const taskGroup_1 = require("../taskGroup");
const PackageVersionUtils_1 = require("../generated/PackageVersionUtils");
const apptelemetryclient_1 = require("../generated/telemetry/apptelemetryclient");
const pp_tooling_telemetry_node_1 = require("../generated/pp-tooling-telemetry-node");
const buildConfig_1 = require("../buildConfig");
const yargs_1 = require("yargs");
const helpers_1 = require("yargs/helpers");
const argv = (0, yargs_1.default)((0, helpers_1.hideBin)(process.argv)).parseSync();
// eslint-disable-next-line @typescript-eslint/no-floating-promises
RunAsync();
async function RunAsync() {
    const telemetryEnv = pp_tooling_telemetry_node_1.AppTelemetryConfigUtility.createGlobalTelemetryEnvironment();
    const version = (0, PackageVersionUtils_1.getPackageVersion)(constants_1.PCF_SCRIPTS_PACKAGE_NAME, process.cwd()) ?? "0.0.1";
    const telemetryClient = (0, apptelemetryclient_1.setupAppInsightsAndClient)(constants_1.PCF_SCRIPTS_PACKAGE_NAME, version, telemetryEnv);
    let result = {};
    let resultCode = 0;
    const startTime = Date.now();
    let buildSource;
    if (argv.buildSource === apptelemetryclient_1.BuildSource[apptelemetryclient_1.BuildSource.VisualStudio]) {
        buildSource = apptelemetryclient_1.BuildSource.VisualStudio;
    }
    else if (argv.buildSource === apptelemetryclient_1.BuildSource[apptelemetryclient_1.BuildSource.MSBuild]) {
        buildSource = apptelemetryclient_1.BuildSource.MSBuild;
    }
    else {
        buildSource = apptelemetryclient_1.BuildSource.NPM;
    }
    const sessionStartProperties = {
        taskGroup: argv._[0],
        buildSource: apptelemetryclient_1.BuildSource[buildSource],
        ...pp_tooling_telemetry_node_1.AppTelemetryUtility.createCommonAppStartProperties(telemetryEnv),
    };
    try {
        telemetryClient.trackEvent({
            name: apptelemetryclient_1.TelemetryEvent[apptelemetryclient_1.TelemetryEvent.Start],
            properties: { ...sessionStartProperties },
        });
        if (!argv?._?.length || !Object.keys(taskGroup_1.standardTaskGroups).includes(argv._[0].toString())) {
            printUsage();
            resultCode = 400;
            return;
        }
        const taskRunner = new taskRunner_1.TaskRunner(argv, (0, buildConfig_1.getBuildConfig)());
        result = (await taskRunner.run(taskGroup_1.standardTaskGroups));
        resultCode = 200;
    }
    catch (e) {
        resultCode = 500;
        console.error(`[${constants_1.PCF_SCRIPTS_PACKAGE_NAME}] [Error] encountered unexpected error:\n${e}`);
        telemetryClient.trackException({ exception: e, properties: { trackedAtMemberName: "RunAsync" } });
    }
    finally {
        const isSuccessful = resultCode === 200;
        process.exitCode = isSuccessful ? 0 : 1;
        const customMeasurement = {};
        if (isSuccessful && !!result?.compileTime) {
            customMeasurement.compileTimeMs = result.compileTime;
        }
        telemetryClient.trackEvent({ name: apptelemetryclient_1.TelemetryEvent[apptelemetryclient_1.TelemetryEvent.End], measurements: customMeasurement });
        telemetryClient.trackRequest({
            name: "Session",
            url: "",
            duration: Date.now() - startTime,
            resultCode: resultCode,
            success: isSuccessful,
            properties: { ...sessionStartProperties },
        });
        telemetryClient.flush();
    }
}
function printUsage() {
    console.log("Unsupported command");
    console.log(`Usage: ${constants_1.PCF_SCRIPTS_PACKAGE_NAME} ${Object.keys(taskGroup_1.standardTaskGroups)
        .map((verb) => "[" + verb + "]")
        .join(" ")}`);
}

//# sourceMappingURL=pcf-scripts.js.map
